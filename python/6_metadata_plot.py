#!/usr/bin/python3
# -*- encoding: utf-8 -*-
# 
# Analisis de los metadatos de lago. 
# Se analiza todo un directorio con archivos adquiridos con la rp.

import numpy as np
from scipy import stats, optimize
import matplotlib.pyplot as plt
import matplotlib.dates as mdate
import bz2, os, time

NBINS    = 32  # 32 bines por pulso
ADCBITS  = 14  # 14 bits
TIME_SEP = 8e-9   # 8 ns por punto
BASELINE = 0   # linea de base

data_dir = 'proc/' # Directorio donde se encuentran los datos
plot_dir = 'plot/' # Directorio donde se guardaran las graficas
filename = input('Ingrese el nombre del archivo (*.dat o *.bz2) a procesar : ')
#filename= 'spnk_nogps_2021_07_23_03h00.dat.bz2'
sadq,tepoch,clk_freq,r1,r2,tempi,pres,hv1,hv2,temp1,temp2 = np.loadtxt(os.path.join(data_dir,'mtd_' + filename[:-4]), unpack=1)
#cntri,tch,dt = np.loadtxt(os.path.join(data_dir,'dt_' + filename[:-4]), unpack=1)

def movingaverage (values, window):
    weights = np.repeat(1.0, window)/window
    sma = np.convolve(values, weights, 'valid')
    return sma

#yMA = movingaverage(vn,3)
#ax4.plot(np.arange(len(vn)),vn,'r')
#ax4.plot(np.arange(len(yMA)),yMA)

#para dar formato a los tepoch
#import time
#time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(1549659752))

#First, we build a list of the file names. isfile() is used to skip directories;
#it can be omitted if directories should be included. Then, we sort the list
#in-place, using the modify date as the key.
#https://stackoverflow.com/questions/168409/how-do-you-get-a-directory-listing-sorted-by-creation-date-in-python
#def getfiles(dirpath):
#    '''esta funcion retorna la lista de archivos
#       de un directorio ordenados por tiempo de
#       creación'''
#    a = [s for s in os.listdir(dirpath)
#         if os.path.isfile(os.path.join(dirpath, s))]
#    a.sort(key=lambda s: os.path.getmtime(os.path.join(dirpath, s)))
#    return a
#
##file_bf = bz2.BZ2File(os.path.join(sub_dir, "bftest_nogps_2015_03_25_17h00.dat.bz2"))
##dfile  = bz2.BZ2File(filename)
##mydata = np.fromfile(dfile).reshape(dim,rows,cols)
#

#fig,ax = plt.subplots(nrows=1, ncols=1, figsize=(7,6))
#ax.plot(hv1,time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(tepoch)))
#ax.plot(hv1,time.strftime('%H:%M:%S',time.localtime(tepoch)))
#plt.plot(tepoch.astype('datetime64[s]')[:1000],hv1[:1000]) # ok

# Convert to the correct format for matplotlib.
# mdate.epoch2num converts epoch timestamps to the right format for matplotlib
secs = mdate.epoch2num(tepoch)
fig, ax = plt.subplots(figsize=(7,6))
# Plot the date using plot_date rather than plot
#ax.plot_date(secs,tempi,'r-')
ax.plot_date(secs[::50],pres[::50],'b--', alpha=0.5, label='Pressure')
#ax.plot_date(secs,hv1,'g--')
#ax.plot_date(secs,r1,'k--')
ax.set_ylabel('Pressure (hPa)')
ax.tick_params('y')
ax.legend(loc='upper left')
ax.grid()
# Choose your xtick format string
#date_fmt = '%d-%m-%y %H:%M:%S'
#date_fmt = '%H:%M:%S'
date_fmt = '%H:%M'
# Use a DateFormatter to set the data to the correct format.
date_formatter = mdate.DateFormatter(date_fmt)
ax.xaxis.set_major_formatter(date_formatter)
# Sets the tick labels diagonal so they fit easier.
fig.autofmt_xdate()

#t = np.arange(0.01, 10.0, 0.01)
ax2 = ax.twinx()
#ax2.plot_date(secs,tempi,'r-')
#ax2.set_ylabel('Temp interior', color='r')
#ax2.plot_date(secs,r1,'k--')
#ax2.set_ylabel('Rate ch1', color='r')
ax2.plot_date(secs[::50],tempi[::50],'r-.',alpha=0.7, label='Internal Temp.')
ax2.plot_date(secs[:len(movingaverage(temp1,13))],movingaverage(temp1,13),'g--',alpha=0.5, label='External Temp.')
#ax2.plot_date(secs[::10],temp1[::10],'g.-',alpha=0.1, label='External Temp.')
#ax2.plot_date(secs,temp2,'b--',alpha=0.3)
#ax2.set_ylabel('Ext. and Int. Temperature (deg C)', color='g')
ax2.legend(loc='upper right')
ax2.set_ylabel('Ext. and Int. Temperature (deg C)')
#ax2.tick_params('y', colors='g')
ax2.tick_params('y')
ax2.axis([min(secs),max(secs),min(temp1)-1,max(temp1)+1])

#fig.tight_layout()
plt.savefig(os.path.join(plot_dir,'temp_pres_sensing.pdf'))
plt.show()

"""
===========================
Plots with different scales
===========================

Demonstrate how to do two plots on the same axes with different left and
right scales.

The trick is to use *two different axes* that share the same *x* axis.
You can use separate `matplotlib.ticker` formatters and locators as
desired since the two axes are independent.

Such axes are generated by calling the `Axes.twinx` method.  Likewise,
`Axes.twiny` is available to generate axes that share a *y* axis but
have different top and bottom scales.

The twinx and twiny methods are also exposed as pyplot functions.

"""

#import numpy as np
#import matplotlib.pyplot as plt
#
#fig, ax1 = plt.subplots()
#t = np.arange(0.01, 10.0, 0.01)
#s1 = np.exp(t)
#ax1.plot(t, s1, 'b-')
#ax1.set_xlabel('time (s)')
## Make the y-axis label, ticks and tick labels match the line color.
#ax1.set_ylabel('exp', color='b')
#ax1.tick_params('y', colors='b')
#
#ax2 = ax1.twinx()
#s2 = np.sin(2 * np.pi * t)
#ax2.plot(t, s2, 'r.')
#ax2.set_ylabel('sin', color='r')
#ax2.tick_params('y', colors='r')
#
#fig.tight_layout()
#plt.show()

#Para hacer un histograma de variación de las HV's
fig,ax = plt.subplots(nrows=1, ncols=1, figsize=(7,6))
#h1,bins1=np.histogram(hv1,bins=np.arange(min(hv1),max(hv1) + 1, 1),density=1)
#y1=stats.norm.pdf(bins1,hv1.mean(),hv1.std())
#ax.plot(bins1[:-1],h1,'r',lw=2,label='HV1')
#ax.plot(bins1,y1,'g--',lw=1,label='HV1, $\mu$ = %2.2f, $\sigma^2$ = %2.2f'%(hv1.mean(),hv1.std()**2))

#ch1
binwidth=1
h1,bins1=np.histogram(hv1,bins=np.arange(min(hv1),max(hv1) + binwidth, binwidth),density=1)
#h1,bins1=np.histogram(hbl1,bins='auto',density=1)
y1=stats.norm.pdf(bins1,hv1.mean(),hv1.std())
#plt.clf()
ax.plot(bins1[:-1],h1,'r*',lw=2,label='CH1')
ax.plot(bins1,y1,'g--',lw=1,label='CH1, $\mu$ = %2.2f, $\sigma^2$ = %2.2f'%(hv1.mean(),hv1.std()**2))

#ch2
h2,bins2=np.histogram(hv2,bins=np.arange(min(hv2),max(hv2) + binwidth, binwidth),density=1)
y2=stats.norm.pdf(bins2,hv2.mean(),hv2.std())
ax.plot(bins2[:-1],h2,'k^',lw=2,label='CH2')
ax.plot(bins2,y2,'b',lw=1,label='CH2, $\mu$ = %2.2f, $\sigma^2$ = %2.2f'%(hv2.mean(),hv2.std()**2))

ax.legend(fontsize=13)
#plt.title('Normalized PDF\'s')
#plt.title('Baseline by channel (PDF)')
ax.set_ylabel('Probability Density Function',fontsize=14, fontname='monospace')
ax.set_xlabel('ADC bins',fontsize=14, fontname='monospace')
#plt.ylim(0,0.45)
#plt.xlim(-20,120)
ax.grid()
#plt.savefig('histogramas_baseline.pdf')
plt.show()
                                   

#grafico de los rates por canal
fig,ax=plt.subplots(figsize=(7,6))
ax.plot(r1,'r-*',label='Rates CH1')
ax.plot(r2,'b-^',label='Rates CH2')
plt.legend()
plt.savefig(os.path.join(plot_dir,'rates_ch1_ch2.pdf'))
plt.show()

#grafico de las HV por canal
fig,ax=plt.subplots(figsize=(7,6))
ax.plot(hv1,'r-*',label='HV CH1')
ax.plot(hv2,'b-^',label='HV CH2')
plt.legend()
plt.savefig(os.path.join(plot_dir,'hv_ch1_ch2.pdf'))
plt.show()

#graficos de diferencia temporal
#fig,ax=plt.subplots(figsize=(7,6))
#h1,b1=np.histogram(dt,density=1)
#y1=stats.norm.pdf(b1,dt.mean(),dt.std())
#ax.plot(b1[:-1],h1,'r*',lw=2,label='Diferencia temporal')
#ax.plot(b1,y1,'g--',lw=1,label='$\Delta$ t, $\mu$ = {:2.2f}, $\sigma^2$ = {:2.2f}'.format(dt.mean(),dt.
#std()**2))
#plt.savefig(os.path.join(plot_dir,'diferencia_tempora.pdf'))
#plt.show()

